## 单链表结构
```cpp
struct Node{
    int data; //节点内包含的数据（以int型为例）
    Node* next; //指向的下一个节点
};
```

## 注：以下Node指针均写为List
```cpp
typedef Node* List;
```

##  链表初始化
```cpp
bool InitList(List &ptr_in)
{
    ptr_in = new Node;
    ptr_in->next=NULL;
    return true;
}
```

##  在链表尾部添加数据
```cpp
bool AddNode(List &ptr_in, int data)
{
    List p = ptr_in;
    List add;
    add = new Node;
    add->data=data;
    add->next=NULL;
    while(p->next!=NULL)
    {
        p=p->next;
    }
    p->next=add;
    return true;
}
```

## 打印链表数据
```cpp
void PrintList(List &ptr_in)
{
    List p = ptr_in;
    p=p->next;
    while(p)
    {
        if(p->data)
        {
            cout<<p->data<<' ';
        }
        p=p->next;
    }
    cout<<endl;
}
```

## 销毁链表（内存空间释放）
```cpp
int DestroyList(List &ptr_in)
{
    List p = ptr_in;
    List del;
    while(p!=NULL)
    {
        del=p;
        p=p->next;
        free(del);
    }
    return 0;
}
```

## 清空链表（只保留头节点 其余释放）
```cpp
int ClearList(List &ptr_in)
{
    List p = ptr_in;
    List del;
    p=p->next;
    while(p!=NULL)
    {
        del=p;
        p=p->next;
        free(del);
    }
    ptr_in->next=NULL;
    return 0;
}
```

## 链表插入数据（index是从0开始计数）
```cpp
void InsertList(List &ptr_in, int after_which_index, int data)
{
    List p = ptr_in;
    List insert;
    insert = new Node;
    insert->data = data;
    int current_node_index = 0;
    while(current_node_index < after_which_index)
    {
        p=p->next;
    }
    insert->next = p->next;
    p->next = insert;
}
```

## 链表反转
具体思想讲解可参考[该CSDN文档](https://blog.csdn.net/v_xchen_v/article/details/53067448)
```cpp
void ReverseList(List &ptr_in)
{
    List p,q;
    p=ptr_in->next;
    ptr_in->next=NULL;
    while(p)
    {
        q=p;
        p=p->next;
        q->next=ptr_in->next;
        ptr_in->next=q;
    }
}
```

## 去除链表内的重复数据
```cpp
void RemoveDuplicate(List &ptr_in)
{
    List p = ptr_in;
    p=p->next;
    while(p)
    {
        List q=p;
        while(q->next)
        {
                List qNext = q->next;
                if(qNext->data==p->data)
                {
                    p->next=qNext->next;
                    free(qNext);
                }
                else
                {
                    q=q->next;
                }
        }
        p=p->next;
    }
}
```
